% Montecarlo  - 3D beam, kogia detectability model.
% Kait Frasier
% 7/23/2013
% JAH 9/2017 to make grid search for best fit to percent RL plot
%{
% Modeling individual click detectability = "click counting method"
% This means that every point generated by the model just represents a
% single click. The parameters of each are drawn from a series of
% probability distributions, which ultimately combine to dictate a recieved
% level (RL), at which point a threshold is used to decide whether or not
% the click is "heard".
%}
% close all
tic
clearvars
%Parameters
n = 500; % the number of model runs in the probability distribution
N = 10000; % simulate this many points per model run usually 100000
maxRange = 1000; % in meters
thresh = 132; % click detection threshold (amplitude in dB pp)
RLbins = 120.5:1:190.5; % fix first bin by moving to integer
fignum = 300; % if fignum = 0 make no figures
spVec = {'kogia'}; itSp = 1; species = spVec{itSp};
% Parameters that can have multiple values have %***
diveDepth = [430,100]; %***
% diveDepth = [250:10:600]'; %***
%     div2 = 100*ones(1,length(diveDepth));
%     diveDepth = [diveDepth,div2'];
sdiveDepth = size(diveDepth);
diveDepths = [25,25];
SLm = [210,10]; SLs = [2,3];
descAngle = [63,5]; %***
% descAngle = [45:75]'; %***
%     des2 = 5*ones(1,length(descAngle));
%     descAngle = [descAngle,des2'];
sdescAngle = size(descAngle);
descAngles = [5,5];
clickStartm = [50,50]; clickStarts = [10,10];
direct = [22,2]; %***
% direct = [15:30]';
%     dir2 = 2*ones(1,16);
%     direct = [direct,dir2'];
sdirect = size(direct);
minAmpSm = [33,5]; minAmpBm = [38,5];
botAngle = [30,5]; %***
% botAngle = [20:45]'; %***
%     bot2 = 5*ones(1,length(botAngle));
%     botAngle = [botAngle,bot2'];
sbotAngle  = size(botAngle);
descentPm = [.10 , .05];
%
TLprofile_directory = 'E:\Data\ESME\';
saveDir = 'E:\Data\John Reports\KogiaClick\';
% Check if output directory exits
if ~exist(saveDir,'dir')
    mkdir(saveDir)
end
siteVec = {'DT','GC','MC'};
%siteVec = {'MC'}; itSt = 1; site = siteVec{itSt};
% file with grid search results
fnParms = fullfile(saveDir,sprintf('ClickModel_Parms_%s.txt',...
    species));
fid = fopen(fnParms,'a');
fprintf(fid,'\r\n Num Iterations = %10d',N);
% Parameters that do not change in the loop
fprintf(fid,'\r\n %4d %4d %4d %4d',...
    SLm,SLs);
fprintf(fid,'%4d %4d %4d %4d',...
    clickStartm,clickStarts);
fprintf(fid,'%4d %4d %4d %4d %7.3f %7.3f',...
    minAmpSm,minAmpBm,descentPm);
best = [1000]; %arbitrary large number
%
nsim = sdiveDepth(1) * sdescAngle(1) * sdirect(1) * sbotAngle(1);
dif = zeros(nsim,length(siteVec)); dif3 = zeros(nsim,1);
pD = zeros(nsim,length(siteVec)); pDs = zeros(nsim,length(siteVec));
for itSite = 1:length(siteVec)
    site = siteVec{itSite};
    % TL model
    polarFile = fullfile(TLprofile_directory,...
        sprintf('%skogia_Jan\\118kHz\\%szoom1_118_3DTL_2.mat',site,site));
    disp(polarFile);
    outdir = fileparts(polarFile);
    load(polarFile)
    numAngle = length(thisAngle);
%     if ~exist('botDepthSort','var')
%         botDepthSort = botDepth_interp(IX,:);
%     end
%     % sort the bottom vectors by increasing angle
%     for preIt = 1:length(sortedTLVec)
%         sortedTLVec{preIt}(:,1) = sortedTLVec{preIt}(:,2);
%     end
    rr_int = round(rr(2)-rr(1)); % figure out what the range step size is
    nrr_new = rr_int*nrr;
    rr_new = 0:rr_int:nrr_new; % Real values of the range vector? (in m)
    pDetTotal = nan(n,1);
    binVec = 0:100:maxRange;
    binnedCounts = [];
    binnedPercDet = nan(n,length(binVec)-1);
    % Load measured Percent PP by site
    if (strcmp(siteVec{1,itSite}, 'MC'));
        load('E:\JAH\Kogia\Detections\MC_Kogia\MC_Kogia_pplog.mat');
    elseif (strcmp(siteVec{1,itSite}, 'GC'));
        load('E:\JAH\Kogia\Detections\GC_Kogia\GC_Kogia_pplog.mat');
    elseif (strcmp(siteVec{1,itSite}, 'DT'));
        load('E:\JAH\Kogia\Detections\DT_Kogia\DT_Kogia_pplog.mat');
    end
    % center of bins and nper number of percent for measurements
    botbin = 116; topbin = 140; %used for both model and measurements
    icen = find(center > botbin & center < topbin);
    lnper = log10(nper(icen)); %used for goodness of fit
    inot = find(~isinf(lnper));
    isim = 0; %counter for num of simulations per site
    for itParms1 = 1: sdiveDepth(1)
        diveDepthm = diveDepth(itParms1,:);
        for itParms2 = 1: sdescAngle(1)
            descAnglem = descAngle(itParms2,:);
            for itParms3 = 1: sdirect(1)
                directm = direct(itParms3,:);
                for itParms4 = 1: sbotAngle(1)
                    botAngles = botAngle(itParms4,:);
                    % variables to pick from a distribution for CV estimation
                    diveDepth_mean = diveDepthm(1) + diveDepthm(2)*rand(n,1); % mean dive altitude is somewhere between 175 and 225m
                    diveDepth_std = diveDepths(1) + diveDepths(2)*rand(n,1);% dive depth std. dev. is 10 to 20m
                    SL_mean = SLm(1) + SLm(2)*rand(n,1); % mean source level is between 210 and 220 dB pp - gervais
                    SL_std = SLs(1) + SLs(2)*rand(n,1); % add 2 to 5 db std dev to source level.
                    descAngle_mean = descAnglem(1) + descAnglem(2)*rand(n,1); % mean descent angle in deg, from tyack 2006 for blainvilles;
                    descAngle_std = descAngles(1) + descAngles(2)*rand(n,1); % std deviation of descent angle in deg, from tyack 2006 for blainvilles;
                    clickStart_mean = clickStartm(1) + clickStartm(2)*rand(n,1); % depth in meters at which clicking starts, from tyack 2006 for blainvilles;
                    clickStart_std =  clickStarts(1) + clickStarts(2)*rand(n,1); % depth in meters at which clicking starts, from tyack 2006 for Cuvier's - blainvilles was unbelievably large;
                    directivity = directm(1) + directm(2)*rand(n,1); % directivity is between 25 and 27 dB PP (Zimmer et al 2005: Echolocation clicks of free-ranging Cuvier's beaked whales)
                    minAmpSide_mean = minAmpSm(1) + minAmpSm(2)*rand(n,1); % minimum off-axis dBs down from peak
                    minAmpBack_mean = minAmpBm(1) + minAmpBm(2)*rand(n,1); % minimum off-axis dBs down from peak
                    botAngle_std = botAngles(1) + botAngles(2)*rand(n,1);  % std of vertical angle shift allowed if foraging at depth
                    descentPerc = descentPm(1) + descentPm(2)*rand(n,1);
                    
                   %
                    RLforHist = [];
                    %
                    for itr_n = 1:n  % number of simulations loop
                        if rem(itr_n,100) == 0
                            fprintf('TL computation %d of %d\n', itr_n, n)
                        end                        
                        %%%%% Location Computation %%%%%
                        % rand location
                        randVec = ceil(rand(2,N)'.*repmat([2*maxRange, 2*maxRange], [N, 1]))...
                            - repmat([maxRange, maxRange], [N, 1]);
                        [theta, rho] = cart2pol(randVec(:,1),randVec(:,2));  % convert to polar coord.
                        clear randVec  % trying to save on memory
                        
                        % trim out the locations that are beyond the max range (corners of the
                        % 2*maxRange X 2*maxRange square, since now we are using a pi*maxRange^2
                        % circle)
                        jjj = 1;
                        rho2 = [];
                        theta2 = [];
                        for iii = 1:length(rho)
                            if rho(iii) < maxRange
                                rho2(jjj,1) = rho(iii);
                                theta2(jjj,1) = theta(iii);
                                jjj = jjj+1;
                            end
                        end
                        thetaDeg = 180 + (theta2*180/pi);
                        clear theta rho
                        
                        % go from angle to ref indices 
                        [angleRef,radRef] = angle_ref_comp(thetaDeg,rho2,thisAngle);
                        
                        %%%%% Depth Computation %%%%%
                        % Compute bottom depth at each randomly selected point
                        count0 = 1;
                        tempDepth = zeros(size(angleRef));
                        keepPoint = ones(size(angleRef));
                        
                        diveDepthRef = diveDepth_mean(itr_n) + diveDepth_std(itr_n)...
                            *randn(size(angleRef)); % add variation to dive depth
                        
                        % If there are whales below the seafloor, place them above
                        burrowingWhaleIdx = find(diveDepthRef>=sd);
                        while ~isempty(burrowingWhaleIdx)
                            diveDepthRef(burrowingWhaleIdx) = diveDepth_mean(itr_n)...
                                + diveDepth_std(itr_n)*randn(size(burrowingWhaleIdx)); % add variation to dive depth,
                            burrowingWhaleIdx = find(diveDepthRef>=sd);
                        end
                        % Remove unwanted points from the body of points that will be run
                        % through the rest of the model.
                        rho2 = rho2(keepPoint == 1);
                        theta2 = theta2(keepPoint == 1);
                        thetaDeg = thetaDeg(keepPoint == 1);
                        radRef = radRef(keepPoint == 1);
                        angleRef = angleRef(keepPoint == 1);
                        
                        % Assign last n% to a descent phase
                        % Choose a depth between start of clicking and destination depth
                        % determine off-axis angle
                        descentIdx = (floor((1-descentPerc(itr_n,1))*length(rho2))+1:length(rho2))';
                        dFactor = rand(size(descentIdx));
                        clickStartVec = clickStart_mean(itr_n,1) + clickStart_std(itr_n,1).*randn(size(descentIdx));
                        
                        % If there are whales above the sea surface, put them below it.
                        flyingWhaleIdx = find(clickStartVec<1);
                        while ~isempty(flyingWhaleIdx)
                            clickStartVec(flyingWhaleIdx) = clickStart_mean(itr_n,1) + clickStart_std(itr_n,1).*randn(size(flyingWhaleIdx));
                            flyingWhaleIdx = find(clickStartVec<1);
                        end
                        descentDelta = dFactor.* (diveDepthRef(descentIdx,:) - clickStartVec);
                        diveDepthRef(descentIdx,1) = clickStartVec + descentDelta;
                        
                        %%%%% Beam Angle Computation %%%%%
                        % Assign random beam orientation in horizontal (all orientations equally likely)
                        randAngleVec = ceil(rand(size(rho2)).*359);
                        % Compute vertical component of shift between animal and sensor (sd =
                        % sensor depth)
                        dZ = abs(sd - diveDepthRef);
                        
                        zAngle_180 = ceil(abs(atand(dZ./radRef))+ (botAngle_std(itr_n,1)*randn(size(dZ))));
                        % assign descent angle to descending portion
                        zAngle_180(descentIdx,1) = ceil(abs(atand(dZ(descentIdx,:)./radRef(descentIdx,:))) -...
                            descAngle_mean(itr_n,1) + (descAngle_std(itr_n,1).*randn(size(descentIdx))));
                        
                        zAngle = make360(zAngle_180); % wrap
                        % clear zAngle_180
                        
                        %%%%% Transmission loss (TL) Computation %%%%%
                        % Note, due to computation limitations, directivity does not vary by individual.
                        % The beam pattern is considered to be the same for all individuals within an iteration.
                        % Compute beam pattern:
                        [beam3D,~] = odont_beam_3D(directivity(itr_n,1), [minAmpSide_mean(itr_n,1),minAmpBack_mean(itr_n,1)]);
                        
                        % Compute variation to add to source level
                        SL_adj = SL_std(itr_n,1)*randn(size(zAngle));
                        
                        RL = nan(size(thetaDeg));
                        isheard = zeros(size(thetaDeg));
                        %%%%% Transmission Loss Loop %%%%%
                        for itr2 = 1:length(thetaDeg)
                            % Using vertical and horizontal off axis components, compute beam
                            % related transmission loss
                            beamTL = beam3D(zAngle(itr2), randAngleVec(itr2));
                            
                            % Compute location of this animal in the transmission loss matrix:
                            % Find which row you want to look at:
                            thisRd = rd_all{angleRef(itr2)};
                            [~,thisDepthIdx] = min(abs(thisRd - round(diveDepthRef(itr2))));
                            
                            % record the distance related portion of this transmission loss
                            thisSortedTL = real(sortedTLVec{angleRef(itr2)});
                            distTL = thisSortedTL(thisDepthIdx,ceil(radRef(itr2)./rr_int));
                            
                            % Add up all the sources of TL
                            RL(itr2,1) = SL_mean(itr_n,1) + SL_adj(itr2) - beamTL - distTL;
                            
                            % Is the total TL less than the maximum allowed?
                            if RL(itr2,1)>=thresh
                                isheard(itr2,1) = 1; % detected it
                            end
                        end
                        
                        pDetTotal(itr_n,1) = sum(isheard)./length(isheard)';
                        detVsLoc = [thetaDeg, rho2, isheard];
                        totalSim = rho2';
                        detSim = rho2(isheard==1)';
                        RL_keep = RL(isheard==1); 
%                      RLforHist(itr_n,:) = histc(RL_keep,RLbins); % made bins go 0.5 to 1.5
                        RLforHist(itr_n,:) = hist(RL_keep,RLbins); % move to integer

                        % Compute detections in range bins, so you can make a histogram if desired
                        % Makes more sense for click-based model
                        % preallocate
                        binTot = zeros(length(binVec)-1,1);
                        binDet = zeros(length(binVec)-1,1);
                        
                        for itr3 = 1:length(binVec)-1
                            binTot(itr3) = length(find(totalSim>binVec(itr3) & totalSim<binVec(itr3 +1)));
                            binDet(itr3) = length(find(detSim>binVec(itr3) & detSim<binVec(itr3 +1)));
                        end
                        thisPercent = binDet./binTot;
                        % save the bin counts to the overall set, so you can get means and variances per bin.
                        binnedPercDet(itr_n,:) = thisPercent';
                        binnedCounts(itr_n,:) = binDet';
                        
                    end
                    
                    RLnorm = RLforHist./(repmat(nansum(RLforHist,2),1,size(RLforHist,2)));
                    if (strcmp(species,'kogia'))
                        %JAH *** remove 16 for other than Kogia!
                        RLshift = RLbins-16; %16 is due to 320 versus 200
                    else
                        RLshift = RLbins+1; % not clear why +1 - Kait?
                    end
                    mRL = nanmean(RLnorm)*100; %percentage
                    iRL = find(RLshift > botbin & RLshift < topbin);
                    lRL = log10(mRL(iRL));
                    isim = isim + 1;
                    dif(isim,itSite) = sum((lnper(inot) - lRL(inot)).^2);
                    pD(isim,itSite) = nanmean(pDetTotal)*100;
                    pDs(isim,itSite) = nanstd(pDetTotal)*100;
                    % only parameters that are changing in the loop
                    fprintf(fid,'\r\n %4s %4d %4d %4d %4d',...
                        site,diveDepthm,diveDepths);
                    fprintf(fid,'%4d %4d %4d %4d',...
                        descAnglem,descAngles);
                    fprintf(fid,'%4d %4d %4d %4d dif %8.4f',...
                        directm,botAngles,dif(isim,itSite));
                    fprintf(fid,' P(det) %1.3f std %1.3f', ...
                            pD(isim,itSite), pDs(isim,itSite));
                    if (itSite == length(siteVec))
                        dif3(isim) = sum(dif(isim,:),2);
                        fprintf(fid,' Sum = %8.4f',dif3(isim));
                        if best > dif3(isim)
                            best = dif3(isim);
                            fprintf(fid,' Best = %8.4f',best);
                        end
                    end
                    %
                    if fignum > 0
                        save(fullfile(saveDir,sprintf('%s_clickModelFinalX_%dItr_%s.mat',...
                            site,itr_n,species)),'-mat');
                        % Histogram of detectability as a function of range
                        spots = binVec(1:end-1)+(50);
                        means = nanmean(binnedPercDet)*100;
                        means_keep = (means>0);
                        spots = spots(means_keep);
                        means = means(means_keep);
                        errsTop = nanstd(binnedPercDet(:,means_keep)*100);
                        errsBot = errsTop;
                        toobig = (errsTop + means)>100;
                        toosmall = (means - errsBot)<0;
                        errsTop(toobig) = 100-means(toobig);
                        errsBot(toosmall) = -(0-means(toosmall));
                        
                        % plot Prob Detection
                        figure(fignum); fignum = fignum +1; %clf
                        hb1 = bar(spots,means,1);
                        set(hb1,'EdgeColor','k','FaceColor','w')
                        hold on
                        ha = errorbar(spots,means,errsBot,errsTop,'.k');
                        Xdata = get(ha,'Xdata');
                        % Xdata = get(hb(2),'Xdata');
                        temp = 4:3:length(Xdata);
                        temp(3:3:end) = [];
                        % xleft and xright contain the indices of the left and right endpoints of the horizontal lines
                        xleft = temp; xright = temp+1;
                        Xdata(xleft) = Xdata(xleft) + 20;
                        Xdata(xright) = Xdata(xright) - 20;
                        set(ha,'Xdata',Xdata)
                        plot(spots,means,'-k','LineWidth',3)
                        set(gca,'XTick',binVec(1:end),'FontSize',12)
                        set(gca,'XTickLabel',binVec(1:end))
                        xlabel(gca,'Horizontal Range (m)','FontSize',16)
                        ylabel(gca, 'Probability of Detection (%)','FontSize',16)
                        %title({sprintf(siteVec{1,itSite},' ',...
                        title({sprintf('Max Horiz. Range = %dm; mean P(det) = %1.3f%%; std = %1.3f%%', ...
                            maxRange, nanmean(pDetTotal)*100, nanstd(pDetTotal)*100)},'FontSize',12)
                        print(gcf,'-dpng','-r300',fullfile(saveDir,[site,'_',species,'_clickMod_pDet.png']))
                        saveas(gca,fullfile(saveDir,[site,'_',species,'_clickMod_pDet.fig']))
                        
                        % plot #det versus range
                        figure(fignum); fignum = fignum +1; clf;
                        binCountMean = mean(binnedCounts);
                        binCountStd = std(binnedCounts);
                        binId = find(binCountMean-binCountStd<0);
                        binCountStdBot = binCountStd;
                        binCountStdBot(binId) = binCountMean(binId) ;
                        errorbar(spots,binCountMean(means_keep),binCountStdBot(means_keep),...
                            binCountStd(means_keep),'.k')
                        hold on
                        hb2 = bar(spots,binCountMean(means_keep),1);
                        set(hb2,'EdgeColor','k','FaceColor','w')
                        set(gca,'XTick',binVec(1:1:end))
                        set(gca,'XTickLabel',binVec(1:1:end),'FontSize',12)
                        xlabel(gca,'Horizontal Range (m)','FontSize',16)
                        ylabel(gca, '# of detections','FontSize',16)
                        %title(polarFile)
                        title(siteVec{1,itSite});
                        print(gcf,'-dpng','-r300',fullfile(saveDir,[site,'_',species,'_clickMod_detCountRange.png']))
                        saveas(gca,fullfile(saveDir,[site,'_',species,'_clickMod_detCountRange.fig']))
                        
                        %plot Percent det versus RL dBpp
                        figure(fignum); fignum = fignum +1; clf;
                        hold on;
                        hb3 = bar(RLbins,nanmean(RLnorm)*100,1);
                        set(hb3,'EdgeColor','k','FaceColor','w')
                        xlim([thresh,160])
                        ylim([0,50])
                        xlabel(gca,'RL (dB_p_p re 1\muPa)','FontSize',16)
                        ylabel(gca, 'Percent of detections','FontSize',16)
                        set(gca,'FontSize',12)
                        title(siteVec{1,itSite});
                        print(gcf,'-dpng','-r300',fullfile(saveDir,[site,'_',species,'_clickMod_RLdist.png']))
                        saveas(gca,fullfile(saveDir,[site,'_',species,'_clickMod_RLdist.fig']))
                        
                        % Percent det versus RL as Log plot
                        %note -16 is to correct for 100kHz data versus fullband
                        figure(fignum); fignum = fignum +1; clf;
                        hb4 = bar(RLbins-16,mRL,1,...
                            'barwidth', 1, 'basevalue', 1);
                        set(hb4,'EdgeColor','k','FaceColor','w')
                        xlim([thresh-1-16,172-16])
                        ylim([.001,50])
                        set(gca,'YScale','log')
                        xlabel(gca,'RL (dB_p_p re 1\muPa)','FontSize',16)
                        ylabel(gca, 'Percent of detections','FontSize',16)
                        set(gca,'FontSize',12)
                        hold on;
                        plot(center,nper,'b--o'); % measured data
                        title([siteVec{1,itSite},' Error= ',num2str(dif(itSite))]);
                        print(gcf,'-dpng','-r300',fullfile(saveDir,[site,'_',species,'_clickMod_RLlog.png']))
                        saveas(gca,fullfile(saveDir,[site,'_',species,'_clickMod_RLlog.fig']))
                        %
                        save(fullfile(saveDir,sprintf('ClickModel_%dItr_%s.mat',...
                           itr_n,species)),'-mat');
                    end
                end
            end
        end
    end
end
% Make summary Plot
fignum = fignum +1;
if (sdiveDepth  > 1)
    figure(fignum); fignum = fignum +1; clf;
    subplot(2,1,1);
    plot(diveDepth(:,1),dif3,'b--o');
    xlabel('diveDepth m'); ylabel('Error');
    subplot(2,1,2)
    for it = 1: length(siteVec)
        plot(diveDepth(:,1),pD(:,it));
        hold on
    end
    ylabel('P(det)')
    saveas(gca,fullfile(saveDir,[species,'_diveDepthClick.fig']))
    save(fullfile(saveDir,sprintf('diveDepthclickModel_%dItr_%s.mat',...
                           itr_n,species)),'-mat');
end
if (sdescAngle  > 1)
    figure(fignum); fignum = fignum +1; clf;
    subplot(2,1,1)
    plot(descAngle(:,1),dif3,'b--o')
    xlabel('descAngle deg'); ylabel('Error');
    subplot(2,1,2)
    for it = 1: length(siteVec)
        plot(descAngle(:,1),pD(:,it));
        hold on
    end
    ylabel('P(det)')
    saveas(gca,fullfile(saveDir,[species,'_desAngle.fig']))
    save(fullfile(saveDir,sprintf('descentClickModel_%dItr_%s.mat',...
                           itr_n,species)),'-mat');
end
if (sdirect  > 1)
    figure(fignum); fignum = fignum +1; clf; 
    subplot(2,1,1)
    plot(direct(:,1),dif3,'b--o')
    xlabel('directivity dB'); ylabel('Error');
    ylabel('P(det)')
    subplot(2,1,2)
    for it = 1: length(siteVec)
        plot(direct(:,1),pD(:,it));
        hold on
    end
    saveas(gca,fullfile(saveDir,[species,'_direct.fig']))
    save(fullfile(saveDir,sprintf('directClickModel_%dItr_%s.mat',...
                           itr_n,species)),'-mat');
end
if (sbotAngle  > 1)
    figure(fignum); fignum = fignum +1; clf; 
    subplot(2,1,1)
    plot(botAngle(:,1),dif3,'b--o')
    xlabel('botAngle deg'); ylabel('Error');
    subplot(2,1,2)
    for it = 1: length(siteVec)
        plot(botAngle(:,1),pD(:,it));
        hold on
    end
    ylabel('P(det)')
    saveas(gca,fullfile(saveDir,[species,'_botAngle.fig']))
    save(fullfile(saveDir,sprintf('botAngleClickModel_%dItr_%s.mat',...
                           itr_n,species)),'-mat');
end
fclose(fid);
toc